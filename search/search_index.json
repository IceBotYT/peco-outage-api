{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PECO Outage API","text":"<p>Documentation: https://IceBotYT.github.io/peco-outage-api</p> <p>Source Code: https://github.com/IceBotYT/peco-outage-api</p> <p>PyPI: https://pypi.org/project/peco/</p> <p>A library for interacting with the PECO outage map to gain the numbers from it.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install peco\n</code></pre>"},{"location":"#development","title":"Development","text":"<ul> <li>Clone this repository</li> <li>Requirements:</li> <li>Poetry</li> <li>Python 3.8+</li> <li>Create a virtual environment and install the dependencies</li> </ul> <pre><code>poetry install\n</code></pre> <ul> <li>Activate the virtual environment</li> </ul> <pre><code>poetry shell\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is automatically generated from the content of the docs directory and from the docstrings  of the public signatures of the source code. The documentation is updated and published as a Github Pages page automatically as part each release.</p>"},{"location":"#releasing","title":"Releasing","text":"<p>Trigger the Draft release workflow (press Run workflow). This will update the changelog &amp; version and create a GitHub release which is in Draft state.</p> <p>Find the draft release from the GitHub releases and publish it. When  a release is published, it'll trigger release workflow which creates PyPI  release and deploys updated documentation.</p>"},{"location":"#pre-commit","title":"Pre-commit","text":"<p>Pre-commit hooks run all the auto-formatting (<code>ruff format</code>), linters (e.g. <code>ruff</code> and <code>mypy</code>), and other quality  checks to make sure the changeset is in good shape before a commit/push happens.</p> <p>You can install the hooks with (runs for each commit):</p> <pre><code>pre-commit install\n</code></pre> <p>Or if you want them to run only for each push:</p> <pre><code>pre-commit install -t pre-push\n</code></pre> <p>Or if you want e.g. want to run all checks manually for all files:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>This project was generated using the wolt-python-package-cookiecutter template.</p>"},{"location":"api_docs/","title":"API documentation","text":"<p>Main object for getting the PECO outage counter data.</p>"},{"location":"api_docs/#peco.BadJSONError","title":"<code>BadJSONError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the JSON is invalid.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>class BadJSONError(Exception):\n    \"\"\"Raised when the JSON is invalid.\"\"\"\n\n    def __init__(self, message: str = \"Bad JSON returned from PECO\") -&gt; None:\n        super().__init__(message)\n</code></pre>"},{"location":"api_docs/#peco.HttpError","title":"<code>HttpError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an error during HTTP request occurs.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>class HttpError(Exception):\n    \"\"\"Raised when an error during HTTP request occurs.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"Bad response from PECO\")\n</code></pre>"},{"location":"api_docs/#peco.IncompatibleMeterError","title":"<code>IncompatibleMeterError</code>","text":"<p>               Bases: <code>MeterError</code></p> <p>Raised when the meter is not compatible with the API.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>class IncompatibleMeterError(MeterError):\n    \"\"\"Raised when the meter is not compatible with the API.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"Meter is not compatible with the API\")\n</code></pre>"},{"location":"api_docs/#peco.InvalidCountyError","title":"<code>InvalidCountyError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when the county is invalid.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>class InvalidCountyError(ValueError):\n    \"\"\"Raised when the county is invalid.\"\"\"\n\n    def __init__(self, county: str) -&gt; None:\n        super().__init__(f\"{county} is not a valid county\")\n</code></pre>"},{"location":"api_docs/#peco.MeterError","title":"<code>MeterError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Generic meter error.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>class MeterError(Exception):\n    \"\"\"Generic meter error.\"\"\"\n</code></pre>"},{"location":"api_docs/#peco.PecoOutageApi","title":"<code>PecoOutageApi</code>","text":"<p>Main object for getting the PECO outage counter data.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>class PecoOutageApi:\n    \"\"\"Main object for getting the PECO outage counter data.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PECO outage counter object.\"\"\"\n\n    @staticmethod\n    async def get_request(\n        url: str,\n        websession: aiohttp.ClientSession | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Make a GET request to the API.\"\"\"\n        data: dict[str, Any]\n        if websession is not None:\n            async with websession.get(url) as r:\n                data = await r.json()\n        else:\n            async with aiohttp.ClientSession() as session, session.get(url) as r:\n                data = await r.json()\n\n        if r.status != STATUS_OK:\n            raise HttpError\n\n        return data\n\n    @staticmethod\n    async def post_request(\n        url: str,\n        data: dict[str, Any],\n        websession: aiohttp.ClientSession | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Make a POST request to the API.\"\"\"\n        if websession is not None:\n            async with websession.post(url, json=data) as r:\n                data = await r.json(content_type=\"text/html\")\n        else:\n            async with aiohttp.ClientSession() as session, session.post(\n                url,\n                json=data,\n            ) as r:\n                data = await r.json(content_type=\"text/html\")\n\n        if r.status != STATUS_OK:\n            raise HttpError\n\n        return data\n\n    async def get_outage_count(\n        self: PecoOutageApi,\n        county: str,\n        websession: aiohttp.ClientSession | None = None,\n    ) -&gt; OutageResults:\n        \"\"\"Get the outage count for the given county.\"\"\"\n\n        if county not in COUNTY_LIST:\n            raise InvalidCountyError(county)\n\n        data = await self.get_request(API_URL, websession)\n\n        try:\n            id_that_has_the_report: str = data[\"data\"][\"interval_generation_data\"]\n        except KeyError as err:\n            raise BadJSONError from err\n\n        report_url = REPORT_URL.format(id_that_has_the_report)\n        data = await self.get_request(report_url, websession)\n\n        try:\n            areas: list[dict[str, Any]] = data[\"file_data\"][\"areas\"]\n        except KeyError as err:\n            raise BadJSONError from err\n\n        outage_result: OutageResults = OutageResults(\n            customers_out=0,\n            percent_customers_out=0,\n            outage_count=0,\n            customers_served=0,\n        )\n        for area in areas:\n            if area[\"name\"] == county:\n                customers_out = area[\"cust_a\"][\"val\"]\n                percent_customers_out = area[\"percent_cust_a\"][\"val\"]\n                outage_count = area[\"n_out\"]\n                customers_served = area[\"cust_s\"]\n                outage_result = OutageResults(\n                    customers_out=customers_out,\n                    percent_customers_out=percent_customers_out,\n                    outage_count=outage_count,\n                    customers_served=customers_served,\n                )\n        return outage_result\n\n    async def get_outage_totals(\n        self: PecoOutageApi,\n        websession: aiohttp.ClientSession | None = None,\n    ) -&gt; OutageResults:\n        \"\"\"Get the outage totals for the given county and mode.\"\"\"\n        data = await self.get_request(API_URL, websession)\n\n        try:\n            id_that_has_the_report: str = data[\"data\"][\"interval_generation_data\"]\n        except KeyError as err:\n            raise BadJSONError from err\n\n        report_url = REPORT_URL.format(id_that_has_the_report)\n        data = await self.get_request(report_url, websession)\n\n        try:\n            totals = data[\"file_data\"][\"totals\"]\n        except KeyError as err:\n            raise BadJSONError from err\n\n        return OutageResults(\n            customers_out=totals[\"cust_a\"][\"val\"],\n            percent_customers_out=totals[\"percent_cust_a\"][\"val\"],\n            outage_count=totals[\"n_out\"],\n            customers_served=totals[\"cust_s\"],\n        )\n\n    async def meter_check(\n        self: PecoOutageApi,\n        phone_number: str,\n        websession: aiohttp.ClientSession | None = None,\n    ) -&gt; bool:\n        \"\"\"Check if power is being delivered to the house.\"\"\"\n        if len(phone_number) != PHONE_NUMBER_LENGTH:\n            msg = \"Phone number must be 10 digits\"\n            raise ValueError(msg)\n\n        if not phone_number.isdigit():\n            msg = \"Phone number must be numeric\"\n            raise ValueError(msg)\n\n        data1 = await self.post_request(QUERY_URL, {\"phone\": phone_number}, websession)\n\n        if not data1[\"success\"]:\n            raise HttpError\n\n        if not data1[\"data\"][0][\"smartMeterStatus\"]:\n            raise IncompatibleMeterError\n\n        auid = data1[\"data\"][0][\"auid\"]\n        acc_number = data1[\"data\"][0][\"accountNumber\"]\n\n        data2 = await self.post_request(\n            PRECHECK_URL,\n            {\n                \"auid\": auid,\n                \"accountNumber\": acc_number,\n                \"phone\": phone_number,\n            },\n            websession,\n        )\n\n        if not data2[\"success\"]:\n            raise HttpError\n\n        if not data2[\"data\"][\"meterPing\"]:\n            raise UnresponsiveMeterError\n\n        data3 = await self.post_request(\n            PING_URL,\n            {\"auid\": auid, \"accountNumber\": acc_number},\n            websession,\n        )\n\n        if not data3[\"success\"]:\n            raise HttpError\n\n        return bool(data3[\"data\"][\"meterInfo\"][\"pingResult\"])\n\n    async def get_map_alerts(\n        self: PecoOutageApi,\n        websession: aiohttp.ClientSession | None = None,\n    ) -&gt; AlertResults:\n        \"\"\"Get the alerts that show on the outage map.\"\"\"\n        data = await self.get_request(API_URL, websession)\n\n        try:\n            alert_deployment_id: str = data[\"controlCenter\"][\"alertDeploymentId\"]\n        except KeyError as err:\n            raise BadJSONError from err\n\n        if alert_deployment_id is None:\n            # No alert\n            return AlertResults(alert_content=\"\", alert_title=\"\")\n\n        alerts_url = ALERTS_URL.format(alert_deployment_id)\n        data1 = await self.get_request(alerts_url, websession)\n\n        # There is always only one alert.\n        # Again, if anyone sees more than one alert, please open an issue.\n        try:\n            alert = data1[\"_embedded\"][\"deployedAlertResourceList\"][0][\"data\"][0]\n        except KeyError:\n            return AlertResults(\n                alert_content=\"\",\n                alert_title=\"\",\n            )\n\n        parsed_content = TAG_RE.sub(\"\", alert[\"content\"].replace(\"&lt;br /&gt;\", \"\\n\\n\"))\n\n        return AlertResults(\n            alert_content=parsed_content,\n            alert_title=alert[\"bannerTitle\"],\n        )\n</code></pre>"},{"location":"api_docs/#peco.PecoOutageApi.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize the PECO outage counter object.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PECO outage counter object.\"\"\"\n</code></pre>"},{"location":"api_docs/#peco.PecoOutageApi.get_map_alerts","title":"<code>get_map_alerts(websession: aiohttp.ClientSession | None = None) -&gt; AlertResults</code>  <code>async</code>","text":"<p>Get the alerts that show on the outage map.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>async def get_map_alerts(\n    self: PecoOutageApi,\n    websession: aiohttp.ClientSession | None = None,\n) -&gt; AlertResults:\n    \"\"\"Get the alerts that show on the outage map.\"\"\"\n    data = await self.get_request(API_URL, websession)\n\n    try:\n        alert_deployment_id: str = data[\"controlCenter\"][\"alertDeploymentId\"]\n    except KeyError as err:\n        raise BadJSONError from err\n\n    if alert_deployment_id is None:\n        # No alert\n        return AlertResults(alert_content=\"\", alert_title=\"\")\n\n    alerts_url = ALERTS_URL.format(alert_deployment_id)\n    data1 = await self.get_request(alerts_url, websession)\n\n    # There is always only one alert.\n    # Again, if anyone sees more than one alert, please open an issue.\n    try:\n        alert = data1[\"_embedded\"][\"deployedAlertResourceList\"][0][\"data\"][0]\n    except KeyError:\n        return AlertResults(\n            alert_content=\"\",\n            alert_title=\"\",\n        )\n\n    parsed_content = TAG_RE.sub(\"\", alert[\"content\"].replace(\"&lt;br /&gt;\", \"\\n\\n\"))\n\n    return AlertResults(\n        alert_content=parsed_content,\n        alert_title=alert[\"bannerTitle\"],\n    )\n</code></pre>"},{"location":"api_docs/#peco.PecoOutageApi.get_outage_count","title":"<code>get_outage_count(county: str, websession: aiohttp.ClientSession | None = None) -&gt; OutageResults</code>  <code>async</code>","text":"<p>Get the outage count for the given county.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>async def get_outage_count(\n    self: PecoOutageApi,\n    county: str,\n    websession: aiohttp.ClientSession | None = None,\n) -&gt; OutageResults:\n    \"\"\"Get the outage count for the given county.\"\"\"\n\n    if county not in COUNTY_LIST:\n        raise InvalidCountyError(county)\n\n    data = await self.get_request(API_URL, websession)\n\n    try:\n        id_that_has_the_report: str = data[\"data\"][\"interval_generation_data\"]\n    except KeyError as err:\n        raise BadJSONError from err\n\n    report_url = REPORT_URL.format(id_that_has_the_report)\n    data = await self.get_request(report_url, websession)\n\n    try:\n        areas: list[dict[str, Any]] = data[\"file_data\"][\"areas\"]\n    except KeyError as err:\n        raise BadJSONError from err\n\n    outage_result: OutageResults = OutageResults(\n        customers_out=0,\n        percent_customers_out=0,\n        outage_count=0,\n        customers_served=0,\n    )\n    for area in areas:\n        if area[\"name\"] == county:\n            customers_out = area[\"cust_a\"][\"val\"]\n            percent_customers_out = area[\"percent_cust_a\"][\"val\"]\n            outage_count = area[\"n_out\"]\n            customers_served = area[\"cust_s\"]\n            outage_result = OutageResults(\n                customers_out=customers_out,\n                percent_customers_out=percent_customers_out,\n                outage_count=outage_count,\n                customers_served=customers_served,\n            )\n    return outage_result\n</code></pre>"},{"location":"api_docs/#peco.PecoOutageApi.get_outage_totals","title":"<code>get_outage_totals(websession: aiohttp.ClientSession | None = None) -&gt; OutageResults</code>  <code>async</code>","text":"<p>Get the outage totals for the given county and mode.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>async def get_outage_totals(\n    self: PecoOutageApi,\n    websession: aiohttp.ClientSession | None = None,\n) -&gt; OutageResults:\n    \"\"\"Get the outage totals for the given county and mode.\"\"\"\n    data = await self.get_request(API_URL, websession)\n\n    try:\n        id_that_has_the_report: str = data[\"data\"][\"interval_generation_data\"]\n    except KeyError as err:\n        raise BadJSONError from err\n\n    report_url = REPORT_URL.format(id_that_has_the_report)\n    data = await self.get_request(report_url, websession)\n\n    try:\n        totals = data[\"file_data\"][\"totals\"]\n    except KeyError as err:\n        raise BadJSONError from err\n\n    return OutageResults(\n        customers_out=totals[\"cust_a\"][\"val\"],\n        percent_customers_out=totals[\"percent_cust_a\"][\"val\"],\n        outage_count=totals[\"n_out\"],\n        customers_served=totals[\"cust_s\"],\n    )\n</code></pre>"},{"location":"api_docs/#peco.PecoOutageApi.get_request","title":"<code>get_request(url: str, websession: aiohttp.ClientSession | None = None) -&gt; dict[str, Any]</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Make a GET request to the API.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>@staticmethod\nasync def get_request(\n    url: str,\n    websession: aiohttp.ClientSession | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Make a GET request to the API.\"\"\"\n    data: dict[str, Any]\n    if websession is not None:\n        async with websession.get(url) as r:\n            data = await r.json()\n    else:\n        async with aiohttp.ClientSession() as session, session.get(url) as r:\n            data = await r.json()\n\n    if r.status != STATUS_OK:\n        raise HttpError\n\n    return data\n</code></pre>"},{"location":"api_docs/#peco.PecoOutageApi.meter_check","title":"<code>meter_check(phone_number: str, websession: aiohttp.ClientSession | None = None) -&gt; bool</code>  <code>async</code>","text":"<p>Check if power is being delivered to the house.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>async def meter_check(\n    self: PecoOutageApi,\n    phone_number: str,\n    websession: aiohttp.ClientSession | None = None,\n) -&gt; bool:\n    \"\"\"Check if power is being delivered to the house.\"\"\"\n    if len(phone_number) != PHONE_NUMBER_LENGTH:\n        msg = \"Phone number must be 10 digits\"\n        raise ValueError(msg)\n\n    if not phone_number.isdigit():\n        msg = \"Phone number must be numeric\"\n        raise ValueError(msg)\n\n    data1 = await self.post_request(QUERY_URL, {\"phone\": phone_number}, websession)\n\n    if not data1[\"success\"]:\n        raise HttpError\n\n    if not data1[\"data\"][0][\"smartMeterStatus\"]:\n        raise IncompatibleMeterError\n\n    auid = data1[\"data\"][0][\"auid\"]\n    acc_number = data1[\"data\"][0][\"accountNumber\"]\n\n    data2 = await self.post_request(\n        PRECHECK_URL,\n        {\n            \"auid\": auid,\n            \"accountNumber\": acc_number,\n            \"phone\": phone_number,\n        },\n        websession,\n    )\n\n    if not data2[\"success\"]:\n        raise HttpError\n\n    if not data2[\"data\"][\"meterPing\"]:\n        raise UnresponsiveMeterError\n\n    data3 = await self.post_request(\n        PING_URL,\n        {\"auid\": auid, \"accountNumber\": acc_number},\n        websession,\n    )\n\n    if not data3[\"success\"]:\n        raise HttpError\n\n    return bool(data3[\"data\"][\"meterInfo\"][\"pingResult\"])\n</code></pre>"},{"location":"api_docs/#peco.PecoOutageApi.post_request","title":"<code>post_request(url: str, data: dict[str, Any], websession: aiohttp.ClientSession | None = None) -&gt; dict[str, Any]</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Make a POST request to the API.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>@staticmethod\nasync def post_request(\n    url: str,\n    data: dict[str, Any],\n    websession: aiohttp.ClientSession | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Make a POST request to the API.\"\"\"\n    if websession is not None:\n        async with websession.post(url, json=data) as r:\n            data = await r.json(content_type=\"text/html\")\n    else:\n        async with aiohttp.ClientSession() as session, session.post(\n            url,\n            json=data,\n        ) as r:\n            data = await r.json(content_type=\"text/html\")\n\n    if r.status != STATUS_OK:\n        raise HttpError\n\n    return data\n</code></pre>"},{"location":"api_docs/#peco.UnresponsiveMeterError","title":"<code>UnresponsiveMeterError</code>","text":"<p>               Bases: <code>MeterError</code></p> <p>Raised when the meter is not responding.</p> Source code in <code>src/peco/__init__.py</code> <pre><code>class UnresponsiveMeterError(MeterError):\n    \"\"\"Raised when the meter is not responding.\"\"\"\n\n    def __init__(self, message: str = \"Meter is not responding\") -&gt; None:\n        super().__init__(message)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#011-2024-06-21","title":"0.1.1 - 2024-06-21","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed pydantic dependency</li> </ul>"},{"location":"changelog/#010-2024-06-21","title":"0.1.0 - 2024-06-21","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Updated project structure, should not affect package usage though</li> </ul>"}]}